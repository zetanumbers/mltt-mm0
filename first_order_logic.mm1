delimiter $ ( ~ $  $ ) , $;

provable sort wff;

term im: wff > wff > wff;
infixr im: $=>$ prec 25;

axiom ax_K (a b: wff): $ a => b => a $;
axiom ax_S (a b c: wff): $ (a => b => c) => (a => b) => (a => c) $;
axiom mp (a b: wff): $ a => b $ > $ a $ > $ b $;
theorem mp2 (a b c: wff) (f: $ a => b => c $) (ha: $ a $) (hb: $ b $): $ c $ = '(mp (mp f ha) hb);
theorem mp3 (a b c d: wff) (f: $ a => b => c => d $) (ha: $a$) (hb: $b$) (hc: $c$): $d$ = '(mp (mp (mp f ha) hb) hc);

term conj: wff > wff > wff;
infixl conj: $/\$ prec 35;
axiom conj_intro (a b: wff): $ a => b => a /\ b $;
axiom conj_elim_1 (a b: wff): $ a /\ b => a $;
axiom conj_elim_2 (a b: wff): $ a /\ b => b $;

term TT: wff;
axiom TT_intro: $ TT $;

term disj: wff > wff > wff;
infixl disj: $\/$ prec 30;
axiom disj_intro_1 (a b: wff): $ a => a \/ b $;
axiom disj_intro_2 (a b: wff): $ b => a \/ b $;
axiom disj_elim (a b c: wff): $ (a => c) => (b => c) => a \/ b => c $;

term FF: wff;
axiom FF_elim (a: wff): $ FF => a $;

theorem id (a: wff): $ a => a $ = '(mp2 ax_S ax_K (! ax_K _ a));
theorem into_TT (a: wff): $ a => TT $ = '(mp ax_K TT_intro);
--| Also the B combinator
theorem compose (a b c: wff): $ (b => c) => (a => b) => (a => c) $ = '(mp2 ax_S (mp ax_K ax_S) ax_K);

do {
    (def (contains v e) @ match e
        ['(mp ,a ,b) @ or (contains v a) (contains v b)]
        ['(mp2 ,a ,b ,c) @ or (contains v a) (contains v b) (contains v c)]
        ['(mp3 ,a ,b ,c ,d) @ or (contains v a) (contains v b) (contains v c) (contains v d)]
        ['(,a) (contains v a)]
        [a {a == v}])

    --| FOL lambda abstraction
    (def (lam v e) @
        if (not @ contains v e) '(mp ax_K ,e) @
        match e
            ['(mp ,a ,b) @
                if (not @ contains v a)
                    (if (and (atom? b) {v == b})
                        a -- eta-conversion
                        '(mp2 compose ,a ,(lam v b))) -- compose optimization
                    -- \x.(t1 t2) => S (\x.t1) (\x.t2)
                    '(mp2 ax_S ,(lam v a) ,(lam v b))]
            -- unfold mp2 into mp mp
            ['(mp2 ,a ,b ,c) (lam v '(mp (mp ,a ,b) ,c))]
            -- unfold mp3 into mp mp mp
            ['(mp3 ,a ,b ,c ,d) (lam v '(mp (mp (mp ,a ,b) ,c) ,d))]
            -- recurse on list with one element
            ['(,a) (lam v a)]
            -- \x.x => I or \x.const => K const
            [a @ if {a == v} 'id '(mp ax_K ,a)])

    (def (lamn vs e) @ if (null? vs) e (lam (hd vs) (lamn (tl vs) e)))

    --| Shallow add modus ponens to an s-expression
    (def (mp_fold l) @
        if (null? l) '() @
        if (atom? l) l @
        if (null? (tl l)) (hd l) @
        letrec ([fst (hd l)] [snd (hd (tl l))] [tail (tl (tl l))])
        (mp_fold (cons '(mp ,fst ,snd) ,tail)))
    --| Recursivelly add modus ponens to an s-expression
    (def (mp_rec_unfold l) @ if (null? l) '() @ if (atom? l) l @ cons (mp_rec (hd l)) @ mp_rec_unfold (tl l))
    --| Add modus ponens to an s-expression
    (def (mp_rec l) @ mp_fold @ mp_rec_unfold l)

    --| l
    (def (lamp vs e) (lamn vs (mp_rec e)))
};

theorem curry (a b c: wff): $ (a /\ b => c) => a => b => c $ = (lamp '(f a b) '(f (conj_intro a b)));
theorem uncurry (a b c: wff): $ (a => b => c) => a /\ b => c $ = (lamp '(f x) '(f (conj_elim_1 x) (conj_elim_2 x)));

def neg (a: wff): wff = $ a => FF $;
prefix neg: $~$ prec 40;
theorem neg_elim (a b: wff): $ ~a => a => b $ = '(mp compose FF_elim);
theorem double_neg_intro (a: wff): $ a => ~~a $ = (lamp '(a f) '(f a));
theorem double_neg_lem (a: wff): $ ~~(a \/ ~a) $ = (lamp '(f) '(f @ disj_intro_2 @ compose f disj_intro_1));
