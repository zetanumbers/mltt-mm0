delimiter $ ( ~ $  $ ) , $;

--| Well-formed formula, or Hilbert-style proposition
provable sort wff;

--| Logical implication
term im: wff > wff > wff;
infixr im: $=>$ prec 10;

--| First Lukasiewicz' axiom, also the K combinator
axiom ax_K (a b: wff): $ a => b => a $;
--| Second Lukasiewicz' axiom, also the S combinator
axiom ax_S (a b c: wff): $ (a => b => c) => (a => b) => (a => c) $;
--| Modus ponens
axiom mp (a b: wff): $ a => b $ > $ a $ > $ b $;
--| Modus ponens 2 times
theorem mp2 (a b c: wff) (f: $ a => b => c $) (ha: $ a $) (hb: $ b $): $ c $ = '(mp (mp f ha) hb);
--| Modus ponens 3 times
theorem mp3 (a b c d: wff) (f: $ a => b => c => d $) (ha: $a$) (hb: $b$) (hc: $c$): $d$ = '(mp (mp (mp f ha) hb) hc);

--| Conjunction
term conj: wff > wff > wff;
infixl conj: $/\$ prec 30;
--| Conjunction introduction
axiom conj_intro (a b: wff): $ a => b => a /\ b $;
--| Conjunction first elimination
axiom conj_elim_1 (a b: wff): $ a /\ b => a $;
--| Conjunction second elimination
axiom conj_elim_2 (a b: wff): $ a /\ b => b $;

--| True, tautology
term true: wff;
--| True introduction
axiom true_intro: $ true $;

--| Disjunction
term disj: wff > wff > wff;
infixl disj: $\/$ prec 20;
--| Disjunction left introduction
axiom disj_intro_1 (a b: wff): $ a => a \/ b $;
--| Disjunction right introduction
axiom disj_intro_2 (a b: wff): $ b => a \/ b $;
--| Disjunction elimination
axiom disj_elim (a b c: wff): $ (a => c) => (b => c) => a \/ b => c $;

--| False, contradiction from minimal logic
term false: wff;

do {
    --| Add modus ponens to an s-expression
    (def (mp_fold l) @ mp_fold_shallow @ mp_fold_deep_only l)

    (def (mp_fold_deep_only l) @
        if (null? l) '() @
        if (atom? l) l @
        cons (mp_fold (hd l)) @ mp_fold_deep_only (tl l))
    (def (mp_fold_shallow l) @
        if (null? l) '() @
        if (atom? l) l @
        if (null? (tl l)) (hd l) @
        if {(hd l) == '!} l @
        mp_fold_shallow (cons '(mp ,(hd l) ,(hd @ tl l)) @ tl @ tl l))
};

--| Identity, also the I combinator
theorem id (a: wff): $ a => a $ = '(mp2 ax_S ax_K (! ax_K _ a));
theorem anything_implies_true (a: wff): $ a => true $ = '(mp ax_K true_intro);
--| Also the B combinator
theorem compose (a b c: wff): $ (b => c) => (a => b) => (a => c) $ = '(mp2 ax_S (mp ax_K ax_S) ax_K);
--| Also the C combinator
theorem flip (a b c: wff): $ (a => b => c) => b => a => c $ = (mp_fold '(ax_S (ax_S (ax_K compose) ax_S) (ax_K ax_K)));

do {
    (def (contains v e) @ match e
        ['(mp ,a ,b) @ or (contains v a) (contains v b)]
        ['(mp2 ,a ,b ,c) @ or (contains v a) (contains v b) (contains v c)]
        ['(mp3 ,a ,b ,c ,d) @ or (contains v a) (contains v b) (contains v c) (contains v d)]
        ['(,a) (contains v a)]
        [a {a == v}])

    --| Single-variable FOL lambda abstraction
    (def (lam v e) @
        if (not @ contains v e) '(mp ax_K ,e) @
        match e
            ['(mp ,a ,b) @
                if (not @ contains v a) (
                    -- \x.(c x) => c
                    if {(atom? b) and {v == b}} a
                    -- \x.(c t) => B c (\x.t)
                    '(mp2 compose ,a ,(lam v b))) @
                -- \x.(t c) => C (\x.t) c
                if (not @ contains v b) '(mp2 flip ,(lam v a) ,b)
                -- \x.(t1 t2) => S (\x.t1) (\x.t2)
                '(mp2 ax_S ,(lam v a) ,(lam v b))]
            -- unfold mp2 into mp mp
            ['(mp2 ,a ,b ,c) (lam v '(mp (mp ,a ,b) ,c))]
            -- unfold mp3 into mp mp mp
            ['(mp3 ,a ,b ,c ,d) (lam v '(mp (mp (mp ,a ,b) ,c) ,d))]
            -- recurse on list with one element
            ['(,a) (lam v a)]
            -- \x.x => I or \x.c => K c
            [a @ if {a == v} 'id '(mp ax_K ,a)])

    --| Multi-variable FOL lambda abstraction
    (def (lamn vs e) @ if (null? vs) e (lam (hd vs) (lamn (tl vs) e)))

    --| FOL lambda abstraction with modus ponens folding
    (def (lamp vs e) (lamn vs (mp_fold e)))
};

-- Tests
theorem _ (a: wff): $ a => a $ = (lamp '(x) '(ax_K x x));

--| Curry
theorem curry (a b c: wff): $ (a /\ b => c) => a => b => c $ = (lamp '(f a b) '(f (conj_intro a b)));
--| Uncurry
theorem uncurry (a b c: wff): $ (a => b => c) => a /\ b => c $ = (lamp '(f x) '(f (conj_elim_1 x) (conj_elim_2 x)));

theorem conj_sym (a b: wff): $ a /\ b => b /\ a $ = '(mp uncurry (mp flip conj_intro));

theorem conj_assoc_1 (a b c: wff): $ (a /\ b) /\ c => a /\ (b /\ c) $ =
    (lamp '(x) '(conj_intro (conj_elim_1 @ conj_elim_1 x) @ conj_intro (conj_elim_2 @ conj_elim_1 x) (conj_elim_2 x)));

theorem conj_assoc_2 (a b c: wff): $ a /\ (b /\ c) => (a /\ b) /\ c $ =
    (lamp '(x) '(conj_intro (conj_intro (conj_elim_1 x) (conj_elim_1 @ conj_elim_2 x)) (conj_elim_2 @ conj_elim_2 x)));

theorem disj_sym (a b: wff): $ a \/ b => b \/ a $ = '(mp2 disj_elim disj_intro_2 disj_intro_1);

theorem disj_assoc_1 (a b c: wff): $ (a \/ b) \/ c => a \/ (b \/ c) $ =
    '(mp2 disj_elim
        (mp2 disj_elim disj_intro_1 (mp2 compose disj_intro_2 disj_intro_1))
        (mp2 compose disj_intro_2 disj_intro_2));

theorem disj_assoc_2 (a b c: wff): $ a \/ (b \/ c) => (a \/ b) \/ c $ =
    '(mp2 disj_elim
        (mp2 compose disj_intro_1 disj_intro_1)
        (mp2 disj_elim (mp2 compose disj_intro_1 disj_intro_2) disj_intro_2));

--| Logical negation
def neg (a: wff): wff = $ a => false $;
prefix neg: $~$ prec 35;
--| Minimal logic axiom for negation in a Hilbert system
theorem ax_4 (a b: wff): $ (a => b) => (a => ~b) => ~a $ = (lamp '(f g a) '(g a (f a)));
--| Double negation introduction
theorem double_neg_intro (a: wff): $ a => ~~a $ = (lamp '(a f) '(f a));

--| Double negation of LEM
theorem double_neg_lem (a: wff): $ ~~(a \/ ~a) $ = (lamp '(f) '(f @ disj_intro_2 @ compose f disj_intro_1));

def iff (a b: wff): wff = $ (a => b) /\ (b => a) $;
infixr iff: $ <=> $ prec 15;

theorem conj_assoc (a b c: wff): $ (a /\ b) /\ c <=> a /\ (b /\ c) $ =
    '(mp2 conj_intro conj_assoc_1 conj_assoc_2);

theorem disj_assoc (a b c: wff): $ (a \/ b) \/ c <=> a \/ (b \/ c) $ =
    '(mp2 conj_intro disj_assoc_1 disj_assoc_2);
